(defmacro defn
  [name args & body]
  `(def ~name (λ ~args ~@body)))

(defmacro unless
  [pred a b]
  `(if ~pred ~b ~a))

(defn not
  [a]
  (if a false true))

(defn load-file
  [f]
  (eval (read-string (str "(do " (slurp f) ")"))))

(def *gensym-counter* (atom 0))
(defn gensym []
  (symbol (str "G__" (swap! *gensym-counter* (λ [x] (+ 1 x))))))

(defmacro cond
  [& xs]
  (if (> (count xs) 0)
    (list 'if (first xs) (if (> (count xs) 1) (nth xs 1) (error "odd number of forms to cond")) (cons 'cond (rest (rest xs))))))

(defmacro or
  [& xs]
  (if (empty? xs) nil (if (= 1 (count xs)) (first xs) (let* (condvar (gensym)) `(let* (~condvar ~(first xs)) (if ~condvar ~condvar (or ~@(rest xs))))))))

(defn let-fn [bindings body]
  (cond
   ((nil? (cdr bindings))
    `((lambda (~(car (car bindings)))
        ~@body)
      ~(cadr (car bindings))))
   (else
    `((lambda (~(car (car bindings)))
        ~(let-fn (cdr bindings) body))
      ~(cadr (car bindings))))))

(defmacro let
  [bindings & body]
  (let-fn bindings body))

(defmacro is [form]
  `(cond (not ~form) (print (str "Assertion failed:" (quote ~form)))))

(defmacro is= [& body]
  `(cond (not (= ~@body)) (print (str "Equal Assertion failed"))))
